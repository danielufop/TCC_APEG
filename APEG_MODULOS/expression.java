// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on Quinta-feira, 16 de Mar√ßo de 2017 at 09:37:26.
// Edit at your own risk.
// ===========================================================================

import java.io.Reader;
import java.io.IOException;

import xtc.util.Pair;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>expression</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class expression extends ParserBase {

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fexpr;
    Result for_cond;
    Result for_cond$$Plus1;
    Result fand_cond;
    Result fand_cond$$Plus1;
    Result fbool_expr;
    Result faexpr;
    Result faexpr$$Plus1;
    Result fterm;
    Result fterm$$Plus1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result ffactor;
    Result fattribute_ref;
    Result fws;
    Result fID;
    Result fID$$Star1;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class expressionColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public expression(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public expression(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new expressionColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.assign.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result passign(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pattribute_ref(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('=' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pws(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pexpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pws(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (';' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("assign expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pexpr(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fexpr) 
      yyColumn.chunk1.fexpr = pexpr$1(yyStart);
    return yyColumn.chunk1.fexpr;
  }

  /** Actually parse expression.expr. */
  private Result pexpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pcondExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.condExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pcondExpr(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = por_cond(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyRepetition1 = yyChoice1;
        yyRepeated1   = false;
        while (true) {

          yyResult = pequalityOp(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = por_cond(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              continue;
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyResult = pws(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.or_cond.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result por_cond(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.for_cond) 
      yyColumn.chunk1.for_cond = por_cond$1(yyStart);
    return yyColumn.chunk1.for_cond;
  }

  /** Actually parse expression.or_cond. */
  private Result por_cond$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pand_cond(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = por_cond$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pws(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.or_cond$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result por_cond$$Plus1(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.for_cond$$Plus1) 
      yyColumn.chunk1.for_cond$$Plus1 = por_cond$$Plus1$1(yyStart);
    return yyColumn.chunk1.for_cond$$Plus1;
  }

  /** Actually parse expression.or_cond$$Plus1. */
  private Result por_cond$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOP_OR(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pand_cond(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = por_cond$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.and_cond.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pand_cond(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fand_cond) 
      yyColumn.chunk1.fand_cond = pand_cond$1(yyStart);
    return yyColumn.chunk1.fand_cond;
  }

  /** Actually parse expression.and_cond. */
  private Result pand_cond$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pbool_expr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pand_cond$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pws(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.and_cond$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pand_cond$$Plus1(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fand_cond$$Plus1) 
      yyColumn.chunk1.fand_cond$$Plus1 = pand_cond$$Plus1$1(yyStart);
    return yyColumn.chunk1.fand_cond$$Plus1;
  }

  /** Actually parse expression.and_cond$$Plus1. */
  private Result pand_cond$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOP_AND(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pbool_expr(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pand_cond$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.bool_expr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pbool_expr(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fbool_expr) 
      yyColumn.chunk1.fbool_expr = pbool_expr$1(yyStart);
    return yyColumn.chunk1.fbool_expr;
  }

  /** Actually parse expression.bool_expr. */
  private Result pbool_expr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = paexpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = prelOp(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pws(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = paexpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pws(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = null;

                return yyResult.createValue(yyValue, yyError);
              }
            }
          }
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.aexpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result paexpr(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.faexpr) 
      yyColumn.chunk1.faexpr = paexpr$1(yyStart);
    return yyColumn.chunk1.faexpr;
  }

  /** Actually parse expression.aexpr. */
  private Result paexpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = ptermOptUnary(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = paexpr$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pws(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.aexpr$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result paexpr$$Plus1(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.faexpr$$Plus1) 
      yyColumn.chunk1.faexpr$$Plus1 = paexpr$$Plus1$1(yyStart);
    return yyColumn.chunk1.faexpr$$Plus1;
  }

  /** Actually parse expression.aexpr$$Plus1. */
  private Result paexpr$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = paddOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pterm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = paexpr$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.termOptUnary.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result ptermOptUnary(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('-' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pterm(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pws(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pterm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("term opt unary expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pterm(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fterm) 
      yyColumn.chunk1.fterm = pterm$1(yyStart);
    return yyColumn.chunk1.fterm;
  }

  /** Actually parse expression.term. */
  private Result pterm$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pfactor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pterm$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyResult = pws(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.term$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pterm$$Plus1(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fterm$$Plus1) 
      yyColumn.chunk1.fterm$$Plus1 = pterm$$Plus1$1(yyStart);
    return yyColumn.chunk1.fterm$$Plus1;
  }

  /** Actually parse expression.term$$Plus1. */
  private Result pterm$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pmulOp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pfactor(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pterm$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = null;

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.factor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pfactor(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.ffactor) 
      yyColumn.chunk2.ffactor = pfactor$1(yyStart);
    return yyColumn.chunk2.ffactor;
  }

  /** Actually parse expression.factor. */
  private Result pfactor$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 't':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('r' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('u' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyResult = pws(yyIndex);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyValue = null;

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('a' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('l' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('s' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('e' == yyC) {

                          yyResult = pws(yyIndex);
                          yyError  = yyResult.select(yyError);
                          if (yyResult.hasValue()) {

                            yyValue = null;

                            return yyResult.createValue(yyValue, yyError);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        break;

      case '@':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('[' == yyC) {

              yyOption1  = yyIndex;

              yyResult = pws(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;
              }

              yyResult = pexpr(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyOption1  = yyResult.index;

                yyResult = pws(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {

                  yyOption1  = yyResult.index;
                }

                yyC = character(yyOption1);
                if (']' == yyC) {
                  yyIndex = yyOption1 + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '!':
        {
          yyResult = pfactor(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '(':
        {
          yyResult = pws(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pexpr(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pws(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (')' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyValue = null;

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
        break;

      case '\'':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyResult = pLITERAL_CHAR(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
            break;
          }

          yyC = character(yyRepetition1);
          if ('\'' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyResult = pws(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pEXPOENT(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyResult = pws(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 4.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyOption1  = yyRepetition1;

      yyC = character(yyOption1);
      if ('.' == yyC) {
        yyIndex = yyOption1 + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyOption1  = yyRepetition1;
      }


      yyResult = pEXPOENT(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyResult = pws(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('(' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pws(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyResult = pactPars(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pws(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyC = character(yyResult.index);
                if (')' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyResult = pws(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = null;

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Alternative 6.

    yyResult = pattribute_ref(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("factor expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.attribute_ref.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pattribute_ref(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fattribute_ref) 
      yyColumn.chunk2.fattribute_ref = pattribute_ref$1(yyStart);
    return yyColumn.chunk2.fattribute_ref;
  }

  /** Actually parse expression.attribute_ref. */
  private Result pattribute_ref$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('$' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('g' == yyC) {
        yyIndex = yyIndex + 1;

        yyResult = pws(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("attribute_ref expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.actPars.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pactPars(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = paexpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pws(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        while (true) {

          yyC = character(yyRepetition1);
          if (',' == yyC) {
            yyIndex = yyRepetition1 + 1;

            yyResult = paexpr(yyIndex);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
          }
          break;
        }

        yyResult = pws(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("act pars expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.equalityOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pequalityOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '!':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("equality op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.relOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result prelOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("rel op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.addOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result paddOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '+':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("add op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal expression.mulOp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pmulOp(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '%':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("mul op expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal spacing.ws.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pws(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fws) yyColumn.chunk2.fws = pws$1(yyStart);
    return yyColumn.chunk2.fws;
  }

  /** Actually parse spacing.ws. */
  private Result pws$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyResult = pws(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '\t':
        {
          yyResult = pws(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if ('\r' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }

    yyC = character(yyOption1);
    if ('\n' == yyC) {
      yyIndex = yyOption1 + 1;

      yyResult = pws(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          yyResult = pws(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Alternative 4.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if ('\r' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }

    yyC = character(yyOption1);
    if ('\n' == yyC) {
      yyIndex = yyOption1 + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Alternative 5.

    yyC = character(yyStart);
    if ('\r' == yyC) {
      yyIndex = yyStart + 1;

      yyValue = null;

      return new SemanticValue(yyValue, yyIndex, yyError);
    }

    // Done.
    yyError = yyError.select("ws expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal operators.OP_AND.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOP_AND(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('&' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('&' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("o p_ a n d expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal operators.OP_OR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOP_OR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('|' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('|' == yyC) {
        yyIndex = yyIndex + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("o p_ o r expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal lexical.LITERAL_CHAR.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLITERAL_CHAR(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\\' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case 'n':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 'r':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 't':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 'b':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 'f':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '\"':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '\'':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case '\\':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        case 'u':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'd':
                    case 'e':
                    case 'f':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                          case '8':
                          case '9':
                          case 'A':
                          case 'B':
                          case 'C':
                          case 'D':
                          case 'E':
                          case 'F':
                          case 'a':
                          case 'b':
                          case 'c':
                          case 'd':
                          case 'e':
                          case 'f':
                            {
                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;

                                switch (yyC) {
                                case '0':
                                case '1':
                                case '2':
                                case '3':
                                case '4':
                                case '5':
                                case '6':
                                case '7':
                                case '8':
                                case '9':
                                case 'A':
                                case 'B':
                                case 'C':
                                case 'D':
                                case 'E':
                                case 'F':
                                case 'a':
                                case 'b':
                                case 'c':
                                case 'd':
                                case 'e':
                                case 'f':
                                  {
                                    yyValue = null;

                                    return new SemanticValue(yyValue, yyIndex, yyError);
                                  }

                                default:
                                  /* No match. */
                                }
                              }
                            }
                            break;

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        case '_':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Alternative 2.

    yyPredMatched = false;

    yyPredResult = pLITERAL_CHAR$$Choice1(yyStart);
    if (yyPredResult.hasValue()) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyC = character(yyStart);
      if (-1 != yyC) {
        yyIndex = yyStart + 1;

        yyValue = null;

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    } else {
      yyError = yyError.select("l i t e r a l_ c h a r expected", yyStart);
    }

    // Done.
    yyError = yyError.select("l i t e r a l_ c h a r expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.LITERAL_CHAR$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLITERAL_CHAR$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\\':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("l i t e r a l_ c h a r expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal lexical.ID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fID) yyColumn.chunk2.fID = pID$1(yyStart);
    return yyColumn.chunk2.fID;
  }

  /** Actually parse lexical.ID. */
  private Result pID$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyResult = pID$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("ID expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.ID$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pID$$Star1(final int yyStart) throws IOException {
    expressionColumn yyColumn = (expressionColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fID$$Star1) 
      yyColumn.chunk2.fID$$Star1 = pID$$Star1$1(yyStart);
    return yyColumn.chunk2.fID$$Star1;
  }

  /** Actually parse expression.ID$$Star1. */
  private Result pID$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('a' <= yyC) && (yyC <= 'z')) {

        yyResult = pID$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pID$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      case '_':
        {
          yyResult = pID$$Star1(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 3.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal lexical.EXPOENT.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEXPOENT(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEXPOENT$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      final int yyChoice1 = yyOption1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '+':
          {
            yyOption1  = yyIndex;
          }
          break;

        case '-':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyRepetition1 = yyOption1;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyValue = null;

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("EXPOENT expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal expression.EXPOENT$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEXPOENT$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'e':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case 'E':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("EXPOENT expected", yyStart);
    return yyError;
  }

}
